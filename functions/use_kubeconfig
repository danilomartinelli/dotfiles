use_kubeconfig() {
  local name="$1"
  
  # Validate input
  if [[ -z "$name" ]]; then
    echo "❌ Error: Kubeconfig name is required"
    echo "Usage: use_kubeconfig <config_name>"
    return 1
  fi
  
  local upper_name="${name:u}"
  local var="KUBECONFIG_${upper_name}"

  # Check if environment variable exists
  if [[ -z "${(P)var}" ]]; then
    echo "❌ Variable $var not found."
    echo "Available kubeconfigs:"
    env | grep '^KUBECONFIG_' | sed 's/KUBECONFIG_/  - /' | sed 's/=.*//'
    return 1
  fi

  # Create temporary file for kubeconfig
  local TMP_KUBECONFIG
  TMP_KUBECONFIG=$(mktemp) || {
    echo "❌ Failed to create temporary file"
    return 1
  }

  # Decode and save kubeconfig
  echo "${(P)var}" | base64 --decode > "$TMP_KUBECONFIG" || {
    echo "❌ Failed to decode kubeconfig"
    rm -f "$TMP_KUBECONFIG"
    return 1
  }

  # Set environment variables
  export CURRENT_KUBECONFIG="$name"
  export KUBECONFIG="$TMP_KUBECONFIG"

  echo "✅ KUBECONFIG activated for $name → $KUBECONFIG"
  
  # Show current context
  if command -v kubectl &> /dev/null; then
    echo "Current context:"
    kubectl config current-context 2>/dev/null | sed 's/^/  /'
    echo "Cluster info:"
    kubectl cluster-info 2>/dev/null | head -n 1 | sed 's/^/  /'
  fi
}
